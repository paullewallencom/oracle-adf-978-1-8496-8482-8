package com.packtpub.adfguide.ch5.model.view;

import java.sql.CallableStatement;
import java.sql.ResultSet;

import java.sql.SQLException;

import java.sql.Types;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import oracle.jbo.JboException;
import oracle.jbo.Key;
import oracle.jbo.Row;
import oracle.jbo.Variable;
import oracle.jbo.ViewCriteria;
import oracle.jbo.ViewCriteriaItem;
import oracle.jbo.ViewCriteriaManager;
import oracle.jbo.ViewCriteriaRow;
import oracle.jbo.ViewLink;
import oracle.jbo.ViewObject;
import oracle.jbo.common.JboCompOper;
import oracle.jbo.server.AssociationDefImpl;
import oracle.jbo.server.AttributeDefImpl;
import oracle.jbo.server.QueryCollection;
import oracle.jbo.server.RowFilter;
import oracle.jbo.server.RowFilterKey;
import oracle.jbo.server.SQLBuilder;
import oracle.jbo.server.ViewLinkDefImpl;
import oracle.jbo.server.ViewLinkImpl;
import oracle.jbo.server.ViewObjectImpl;
import oracle.jbo.server.ViewRowImpl;
import oracle.jbo.server.ViewRowSetImpl;

import oracle.jdbc.OracleTypes;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Sun Nov 13 18:07:18 IST 2011
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class DepartmentProgrammaticVOImpl extends ViewObjectImpl {
    private ViewLinkDefImpl viewLinkDefImpl;
    private boolean inExecuteEmptyRowSet = false;
    Map<String, String> bindVariableToAttributeNameMapping = null;
    private boolean initialized = false;
    private static final String EQUALS_OPER = "=";
    private static final String LIKE_OPER = "LIKE";

    /**
     * This is the default constructor (do not remove).
     */
    public DepartmentProgrammaticVOImpl() {
    }

    /**
     * executeQueryForCollection - overridden for custom java data source support.
     */
    @Override
    protected void executeQueryForCollection(Object qc, Object[] params, int noUserParams) {
        if (!initialized) {
            initialize();
            initialized = true;
        }

        super.executeQueryForCollection(qc, params, noUserParams);
        if (!performingExecuteEmptyRowSet((QueryCollection)qc)) {
            if (!((QueryCollection)qc).getRowSetImpl().isFetchComplete()) {
                storeNewResultSet(qc, retrieveRefCursor(qc, params, noUserParams));
            }
        }
    }


    @Override
    public void executeEmptyRowSet() {
        try {
            inExecuteEmptyRowSet = true;
            super.executeEmptyRowSet();
        } finally {
            inExecuteEmptyRowSet = false;
        }

    }

    private boolean performingExecuteEmptyRowSet(QueryCollection qc) {
        return inExecuteEmptyRowSet;
    }

    /**
     * Overridden framework method.
     *
     * The role of this method is to "fetch", populate, and return a single row
     * from the datasource by calling createNewRowForCollection() and populating
     * its attributes using populateAttributeForRow().
     */
    @Override
    protected ViewRowImpl createRowFromResultSet(Object qc, ResultSet rs) {
        /*
       * We ignore the JDBC ResultSet passed by the framework (null anyway) and
       * use the resultset that we've stored in the query-collection-private
       * user data storage
       */
        rs = getResultSet(qc);

        /*
       * Create a new row to populate
       */
        ViewRowImpl r = createNewRowForCollection(qc);

        try {
            /*
         * Populate new row by attribute slot number for current row in Result Set
         */
            populateAttributeForRow(r, 0, rs.getInt(1));
            populateAttributeForRow(r, 1, rs.getString(2));
            populateAttributeForRow(r, 2, rs.getInt(3));
            populateAttributeForRow(r, 3, rs.getInt(4));
        } catch (SQLException s) {
            throw new JboException(s);
        }
        return r;
    }

    /**
     * Overridden framework method.
     *
     * Return true if the datasource has at least one more record to fetch.
     */
    @Override
    protected boolean hasNextForCollection(Object qc) {
        ResultSet rs = getResultSet(qc);
        boolean nextOne = false;
        try {
            nextOne = rs.next();
            /*
         * When were at the end of the result set, mark the query collection
         * as "FetchComplete".
         */
            if (!nextOne) {
                setFetchCompleteForCollection(qc, true);
                /*
           * Close the result set, we're done with it
           */
                rs.close();
            }
        } catch (SQLException s) {
            throw new JboException(s);
        }
        return nextOne;
    }

    /**
     * Overridden framework method.
     *
     * The framework gives us a chance to clean up any resources related
     * to the datasource when a query collection is done being used.
     */
    @Override
    protected void releaseUserDataForCollection(Object qc, Object rs) {
        /*
       * Ignore the ResultSet passed in since we've created our own.
       * Fetch the ResultSet from the User-Data context instead
       */
        ResultSet userDataRS = getResultSet(qc);
        if (userDataRS != null) {
            try {
                userDataRS.close();
            } catch (SQLException s) {
                /* Ignore */
            }
        }
        super.releaseUserDataForCollection(qc, rs);
    }

    /**
     * Overridden framework method
     *
     * Return the number of rows that would be returned by executing
     * the query implied by the datasource. This gives the developer a
     * chance to perform a fast count of the rows that would be retrieved
     * if all rows were fetched from the database. In the default implementation
     * the framework will perform a SELECT COUNT(*) FROM (...) wrapper query
     * to let the database return the count. This count might only be an estimate
     * depending on how resource-intensive it would be to actually count the rows.
     */
    @Override
    public long getQueryHitCount(ViewRowSetImpl viewRowSet) {
        Long result =
            (Long)callStoredFunction(Types.NUMERIC, "departments_api.count_departments(?,)", viewRowSet.getParameters(true));
        return result.longValue();
    }

    /**
     * This method executes a count query and returns the number of rows
     * that could end up in the rowset. The count query could be very
     * expensive in some scenarios if we were to execute without an
     * upper limit. The method provides a <code>cap</code> argument
     * so that we can execute a query that aborts the count as soon
     * as the cap is met.
     *
     * @param viewRowSet the rowset that will contain the rows when
     * fetched.
     * @param masterRows the master rows are needed to get the parameters
     * in a master detail scenario to bind to the row count query.
     * @param oldCap current not used.
     * @param cap the limit on the count expected
     * @return +ve number if the row count is less than the limit or
     * limit itself.
     */
    public long getCappedQueryHitCount(ViewRowSetImpl viewRowSet, Row[] masterRows, long oldCap, long cap) {
        Long result =
            (Long)callStoredFunction(Types.NUMERIC, "departments_api.count_departments(?,)", viewRowSet.getParameters(true));
        return result.longValue();
    }

    /**
     * Overrode to  help the destination view object know what view link definition connects
     * @param assocDef
     * @param accessorVO
     * @param masterRow
     * @param values
     * @return
     */
    @Override
    protected ViewRowSetImpl createViewLinkAccessorRS(AssociationDefImpl assocDef, ViewObjectImpl accessorVO,
                                                      Row masterRow, Object[] values) {
        ViewRowSetImpl ret = super.createViewLinkAccessorRS(assocDef, accessorVO, masterRow, values);
        ViewLinkDefImpl vldef = (ViewLinkDefImpl)assocDef.getAssociation();
        ViewObject vo = ret.getViewObject();
        if (vo instanceof DepartmentProgrammaticVOImpl) {
            setViewLinkDefImpl(vldef);
        }
        return ret;
    }

    /**
     * Return a JDBC ResultSet representing the REF CURSOR return
     * value from our stored package function.
     */
    private ResultSet retrieveRefCursor(Object qc, Object[] params, int noUserParams) {

        Map<String, Object> filter = getFilterCriteria((QueryCollection)qc, params, noUserParams);
        ResultSet rs =
            (ResultSet)callStoredFunction(OracleTypes.CURSOR, "departments_api.get_departments(?,?,?,?)", new Object[] { filter.get("DepartmentId"),
                                                                                                                         filter.get("DepartmentName"),
                                                                                                                         filter.get("ManagerId"),
                                                                                                                         filter.get("LocationId") });
        return rs;
    }

    /**
     * Simplifies calling a stored function with bind variables
     *
     * You can use the NUMBER, DATE, and VARCHAR2 constants in this
     * class to indicate the function return type for these three common types,
     * otherwise use one of the JDBC types in the java.sql.Types class.
     *
     * NOTE: If you want to invoke a stored procedure without any bind variables
     * ====  then you can just use the basic getDBTransaction().executeCommand()
     *
     * @param sqlReturnType JDBC datatype constant of function return value
     * @param stmt stored function statement
     * @param bindVars Object array of parameters
     * @return function return value as an Object
     */
    protected Object callStoredFunction(int sqlReturnType, String stmt, Object[] bindVars) {
        CallableStatement st = null;
        try {
            st = getDBTransaction().createCallableStatement("begin ? := " + stmt + "; end;", 0);
            st.registerOutParameter(1, sqlReturnType);
            if (bindVars != null) {
                for (int z = 0; z < bindVars.length; z++) {
                    st.setObject(z + 2, bindVars[z]);
                }
            }
            st.executeUpdate();
            return st.getObject(1);
        } catch (SQLException e) {
            throw new JboException(e);
        }
    }


    /**
     * Store a new result set in the query-collection-private user-data context
     */
    private void storeNewResultSet(Object qc, ResultSet rs) {
        ResultSet existingRs = getResultSet(qc);
        // If this query collection is getting reused, close out any previous rowset
        if (existingRs != null) {
            try {
                existingRs.close();
            } catch (SQLException s) {
            }
        }
        setUserDataForCollection(qc, rs);
        hasNextForCollection(qc); // Prime the pump with the first row.
    }

    /**
     * Retrieve the result set wrapper from the query-collection user-data
     */
    private ResultSet getResultSet(Object qc) {
        return (ResultSet)getUserDataForCollection(qc);
    }

    /**
     * Build the filter filter criteria map which can be used later by the third party
     * service to filter the data. This is used for   row count query
     * @param rowset
     * @return
     */
    private Map<String, Object> getFilterCriteria(QueryCollection qc, Object[] params, int noUserParams) {
        Map<String, Object> filter = new HashMap<String, Object>();

        if (params != null && params.length > 0) {

            /*
          * First hand any user-defined parameters
          */
            if (noUserParams > 0) {
                for (int z = 0; z < noUserParams; z++) {
                    String paramName = null;
                    Object paramValue = null;
                    if (params[z] instanceof Object[]) {
                        Object[] paramObjArr = (Object[])params[z];
                        if (paramObjArr.length == 2 && paramObjArr[0] instanceof String) {
                            paramName = (String)paramObjArr[0];
                            paramValue = paramObjArr[1];
                        }
                    }
                    if (paramName != null && paramValue != null) {
                        filter.put(getFilterAttributeNameToUse(paramName), paramValue);
                    }
                }
            }
            /*
          * Then, handle any viewlink related parameters the system has added
          */
            RowFilter rowFilter = ((QueryCollection)qc).getRowFilter();
            if (rowFilter instanceof RowFilterKey) {
                Key key = ((RowFilterKey)rowFilter).getKey();
                if (key != null && key.getAttributeCount() > 0) {
                    AttributeDefImpl[] attrDefImpls = null;
                    if (viewLinkDefImpl != null) {
                        attrDefImpls = viewLinkDefImpl.getDestinationEnd().getAttributeDefImpls();
                    } else {
                        ViewLink[] viewlinks = getViewLinks();
                        for (ViewLink vl : viewlinks) {
                            if (vl.getDestination() == this) {
                                ViewLinkImpl vli = (ViewLinkImpl)vl;
                                ViewLinkDefImpl vlDef = vli.getViewLinkDef();
                                attrDefImpls = vlDef.getDestinationEnd().getAttributeDefImpls();
                                break;
                            }
                        }
                    }
                    if (attrDefImpls != null) {
                        filter = new HashMap<String, Object>(attrDefImpls.length);
                        int attrSlot = 0;
                        for (AttributeDefImpl attrDef : attrDefImpls) {
                            Object keyValue = key.getAttribute(attrSlot++);
                            filter.put(getFilterAttributeNameToUse(attrDef.getName()), keyValue);
                        }
                    }
                }
            }
        }
        /*
      * Then handle any view criteria
      */
        ViewCriteriaManager vcm = qc.getRowSetImpl().getViewObject().getViewCriteriaManager();
        String[] vcNames = vcm.getApplyViewCriteriaNames();
        if (vcNames != null && vcNames.length > 0) {
            for (String vcName : vcNames) {
                ViewCriteria vc = vcm.getViewCriteria(vcName);
                vc.reset();
                while (vc.hasNext()) {
                    ViewCriteriaRow vcr = (ViewCriteriaRow)vc.next();
                    List<ViewCriteriaItem> vcis = vcr.getCriteriaItems();
                    for (ViewCriteriaItem vci : vcis) {
                        String oper = vci.getOperator();
                        if ((EQUALS_OPER.equals(oper) || LIKE_OPER.equals(oper)) && vci.getValueCount() == 1) {
                            String paramName = vci.getAttributeDef().getName();
                            Object paramValue = null;
                            if (vci.isBindVarValue() && vci.getValue() != null) {
                                String varName = vci.getValue().toString().trim().substring(1);
                                paramValue = vc.ensureVariableManager().getVariableValue(varName);

                            } else {
                                paramValue = vci.getValue(0);
                            }
                            if (filter == null) {
                                filter = new HashMap<String, Object>();
                            }
                            filter.put(paramName, paramValue);
                        }

                    }

                }
            }
        }

        return filter;
    }

    private String getFilterAttributeNameToUse(String attrName) {
        String remappedName = null;
        if (bindVariableToAttributeNameMapping != null) {
            remappedName = bindVariableToAttributeNameMapping.get(attrName);
        }
        return remappedName != null ? remappedName : attrName;
    }

    private void initialize() {
        setManageRowsByKey(true);
        bindVariableToAttributeNameMapping = getBindVariableToAttributeNameMapping();
    }

    protected Map<String, String> getBindVariableToAttributeNameMapping() {
        if (bindVariableToAttributeNameMapping == null) {
            bindVariableToAttributeNameMapping = new HashMap<String, String>();
            Variable[] variables = ensureVariableManager().getVariables();
            if (variables != null && variables.length > 0) {
                for (Variable v : variables) {
                    Object propVal = v.getProperty("MapToAttribute");
                    if (propVal != null) {
                        bindVariableToAttributeNameMapping.put(v.getName(), (String)propVal);
                    }
                }
            }
        }
        return bindVariableToAttributeNameMapping;
    }

    void setViewLinkDefImpl(ViewLinkDefImpl vldef) {
        viewLinkDefImpl = vldef;
    }

    /**
     * Returns the variable value for Variable.
     * @return variable value for Variable
     */
    public String getbindVarDeptName() {
        return (String)ensureVariableManager().getVariableValue("bindVarDeptName");
    }

    /**
     * Sets <code>value</code> for variable Variable.
     * @param value value to bind as Variable
     */
    public void setbindVarDeptName(String value) {
        ensureVariableManager().setVariableValue("bindVarDeptName", value);
    }

    /**
     * Returns the variable value for bindVarLocationId.
     * @return variable value for bindVarLocationId
     */
    public Integer getbindVarLocationId() {
        return (Integer)ensureVariableManager().getVariableValue("bindVarLocationId");
    }

    /**
     * Sets <code>value</code> for variable bindVarLocationId.
     * @param value value to bind as bindVarLocationId
     */
    public void setbindVarLocationId(Integer value) {
        ensureVariableManager().setVariableValue("bindVarLocationId", value);
    }


}
