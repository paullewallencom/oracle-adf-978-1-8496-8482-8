package com.packtpub.adfguide.ch6.model.nondb;

import java.util.Map;

import oracle.jbo.Session;
import oracle.jbo.ViewObject;
import oracle.jbo.server.ApplicationModuleImpl;
import oracle.jbo.server.ComponentObjectImpl;
import oracle.jbo.server.TransactionEvent;
import oracle.jbo.server.ViewDefImpl;
import oracle.jbo.server.ViewObjectImpl;

import oracle.xml.parser.v2.XMLDocument;

import org.w3c.dom.Element;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Sun Dec 04 06:02:23 IST 2011
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class NonDBAppModuleServiceImpl extends ApplicationModuleImpl {
    /**
     * This is the default constructor (do not remove).
     */
    public NonDBAppModuleServiceImpl() {
    }

    /**
     * Container's getter for StaticVO1.
     * @return StaticVO1
     */
    public ViewObjectImpl getStaticVO1() {
        return (ViewObjectImpl)findViewObject("StaticVO1");
    }

    /**
     * Called by the framework when a root Application Module is
     * created. Unlike the {@link #create() create} method which is called even when
     * nested Application Modules are created, this method is called only for
     * the root Application Module.
     * <p>
     * Subclasses can override this method to perform customizations. For example,
     * it can be overriden to initialize connection pools. Another example is
     * to override <tt>activate</tt> to automatically create a connection in the
     * middle tier when the root Application Module is created.
     * <p>
     * If this method is overriden, then subclasses must call the super class
     * first in the custom implementation.
     * <p>
     * Please take special note that this method will only be called once
     * when the root ApplicationModule is created.  Subclasses should extend
     * {@link #prepareSession(Session)} to initialize true session state.
     * <p>
     * @param session the session in which the root Application Module is
     * created.
     *
     * @see #prepareSession(oracle.jbo.Session)
     *
     */
    protected void activate(Session session) throws IllegalStateException {
        super.activate(session);
    }

    /**
     * Allow subclasses to retrieve custom data associated with <b>connection</b>
     * state. Because we realize that clients may store data using a custom
     * approach which does not result in any data residing on our XML nodes,
     * BC4J will invoke this method on all child application modules, regardless
     * of whether we have state to restore for that application module. If no
     * child nodes were added during passivateConnectionState(), then the parent
     * node passed into this method will be null.
     * <p>
     * In addition to being invoked at the conclusion of full passivation (which
     * allows subclasses to encapsulate their connection state data retrieval),
     * this method is also invoked during reconnect() whenever disconnect(true)
     * has been previously called.
     * <p>
     * For reference, the call order during full activation is:
     * <p>
     * Activate Overall State
     * -----------------------
     * 1. prepareForActivation() on root AM.
     * 2. For each nested AM in root AM, cycle from step 1:
     *    2.1. prepareForActivation() on nested AM.
     *    2.2. For each nested AM in the nested AM, cycle from step 1 (recursion).
     *    2.3. activateState() on VOs in the nested AM.
     *    2.4. activateState() on nested AM.
     * 3. activateState() on VOs in root AM.
     * 4. activateState() on root AM.
     * <p>
     * Activate Custom Connection State
     * ---------------------------------
     * 5. activateConnectionState() on root AM.
     * 6. For each nested AM in root AM, cycle from step 1:
     *    6.1. activateConnectionState() on nested AM.
     *    6.2. For each nested AM in the nested AM, cycle from step 1 (recursion).
     * <p>
     * In all cases, clients may expect the application module connection to
     * be valid during these callback methods.
     * <p>
     * @param parent the parent element under which the custom data resides.
     */
    protected void activateConnectionState(Element parent) {
        super.activateConnectionState(parent);
    }

    /**
     * <b>Internal:</b> <em>Applications should not call this method.</em>
     */
    public void activateOpenVOs(XMLDocument out) {
        super.activateOpenVOs(out);
    }

    /**
     * Allows subclasses to retrieve custom data from an XML-node under the given
     * parent element. Specifies the current row for
     * which the key has been passivated.
     * @param parent the name of the parent element under which the custom data resides.
     */
    protected void activateState(Element parent) {
        super.activateState(parent);
    }

    /**
     * <b>Internal:</b> <em>Applications should not use this method.</em>
     * <p>
     * Adds names to this Application Module's own list of child components.
     * The child components can be View Objects, View Links,
     * or other Application Modules. This method overrides an internal
     * <tt>addChild</tt> method in
     * {@link oracle.jbo.server.NamedObjectImpl NamedObjectImpl}.
     * @param object an object to add to the component list.
     * @see oracle.jbo.server.NamedObjectImpl
     */
    protected void addChild(ComponentObjectImpl object) {
        super.addChild(object);
    }

    /**
     * Invoked after the application module database connection has been
     * established.  This method may be overriden by applications to
     * perform application module initialization which requires database
     * access.
     */
    protected void afterConnect() {
        super.afterConnect();
    }

    /**
     * Callback from the transaction after completing a
     * validation iteration. Transaction will call
     * this hook on the root application module. The root
     * application module in turn will call the afterValidate
     * method on all its children
     * @param te  a transaction event.
     */
    protected void afterValidate(TransactionEvent te) {
        super.afterValidate(te);
    }

    protected Map allocatePropertyMap() {
        return super.allocatePropertyMap();
    }

    /**
     * Invoked before the application module database connection has been
     * released.  This method may be overriden by applications to
     * cleanup any database state which may have been created by afterConnect.
     */
    protected void beforeDisconnect() {
        super.beforeDisconnect();
    }

    /**
     * Creates and returns a copy of this object.  The precise meaning
     * of "copy" may depend on the class of the object. The general
     * intent is that, for any object <tt>x</tt>, the expression:
     * <blockquote>
     * <pre>
     * x.clone() != x</pre></blockquote>
     * will be true, and that the expression:
     * <blockquote>
     * <pre>
     * x.clone().getClass() == x.getClass()</pre></blockquote>
     * will be <tt>true</tt>, but these are not absolute requirements.
     * While it is typically the case that:
     * <blockquote>
     * <pre>
     * x.clone().equals(x)</pre></blockquote>
     * will be <tt>true</tt>, this is not an absolute requirement.
     * <p>
     * By convention, the returned object should be obtained by calling
     * <tt>super.clone</tt>.  If a class and all of its superclasses (except
     * <tt>Object</tt>) obey this convention, it will be the case that
     * <tt>x.clone().getClass() == x.getClass()</tt>.
     * <p>
     * By convention, the object returned by this method should be independent
     * of this object (which is being cloned).  To achieve this independence,
     * it may be necessary to modify one or more fields of the object returned
     * by <tt>super.clone</tt> before returning it.  Typically, this means
     * copying any mutable objects that comprise the internal "deep structure"
     * of the object being cloned and replacing the references to these
     * objects with references to the copies.  If a class contains only
     * primitive fields or references to immutable objects, then it is usually
     * the case that no fields in the object returned by <tt>super.clone</tt>
     * need to be modified.
     * <p>
     * The method <tt>clone</tt> for class <tt>Object</tt> performs a
     * specific cloning operation. First, if the class of this object does
     * not implement the interface <tt>Cloneable</tt>, then a
     * <tt>CloneNotSupportedException</tt> is thrown. Note that all arrays
     * are considered to implement the interface <tt>Cloneable</tt>.
     * Otherwise, this method creates a new instance of the class of this
     * object and initializes all its fields with exactly the contents of
     * the corresponding fields of this object, as if by assignment; the
     * contents of the fields are not themselves cloned. Thus, this method
     * performs a "shallow copy" of this object, not a "deep copy" operation.
     * <p>
     * The class <tt>Object</tt> does not itself implement the interface
     * <tt>Cloneable</tt>, so calling the <tt>clone</tt> method on an object
     * whose class is <tt>Object</tt> will result in throwing an
     * exception at run time.
     *
     * @return a clone of this instance.
     * @exception CloneNotSupportedException if the object's class does not
     * support the <code>Cloneable</code> interface. Subclasses
     * that override the <code>clone</code> method can also
     * throw this exception to indicate that an instance cannot
     * be cloned.
     * @see Cloneable
     */
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    protected void create() {
        super.create();
    }

    /**
     * Callback from the transaction before starting a
     * validation iteration. Transaction will call
     * this hook on the root application module. The root
     * application module in turn will call the beforeValidate
     * method on all its children
     * @param te  a transaction event.
     */
    protected void beforeValidate(TransactionEvent te) {
        super.beforeValidate(te);
    }

    protected ViewObject createViewObject(String voName, ViewDefImpl viewDef) {
        return super.createViewObject(voName, viewDef);
    }

    /**
     * Allows subclasses to store custom data associated with <b>connection</b>
     * state. Custom data may be saved either as XML-nodes under the given parent
     * element, or via a custom approach.
     * <p>
     * In addition to being invoked prior to full passivation (which allows
     * subclasses to encapsulate their connection state data storage), this
     * method is also invoked as part of disconnect(true). In this latter case,
     * the aim is to allow subclasses to store their connection specific data
     * in memory prior to recycling of the JDBC connection. This data (such as
     * open cursors or PL-SQL global variables) can then be restored when the
     * connection is restored.
     * <p>
     * For reference, the call order during full passivation is:
     * <p>
     * Passivate Custom Connection State
     * ---------------------------------
     * 1. For each nested AM in root AM, cycle from step 1:
     *    1.1. For each nested AM in the nested AM, cycle from step 1 (recursion).
     *    1.2. passivateConnectionState() on nested AM.
     * 2. passivateConnectionState() on root AM.
     * <p>
     * Passivate Overall State
     * -----------------------
     * 3. prepareForPassivation() on root AM.
     * 4. passivateState() on VOs in root AM.
     * 5. For each nested AM in root AM, cycle from step 1:
     *    5.1. prepareForPassivation() on nested AM.
     *    5.2. passivateState() on VOs in nested AM.
     *    5.3. For each nested AM in the nested AM, cycle from step 1 (recursion).
     *    5.4. passivateState() on nested AM.
     * 6. passivateState() on root AM.
     * <p>
     * In all cases, clients may expect the application module connection to
     * be valid during these callback methods.
     * <p>
     * @param doc the XML document in which custom data may be stored.
     * @param parent the parent element under which custom data may be stored.
     */
    protected void passivateConnectionState(org.w3c.dom.Document doc, Element parent) {
        super.passivateConnectionState(doc, parent);
    }

    /**
     * Allows subclasses to abort activation, when the metadata for the component
     * objects has changed and an attempt is made to activate an Application Module
     * which was saved with an older version of the metadata.
     *
     * @param activatedTS The meta-data definition version that the ApplicationModule
     * being activated was passivated with. Currently this version object is a Long
     * value. However Applications should not rely on the fact that this object
     * will be of type Long in future.
     */
    protected void handleDefinitionChangedOnActivate(Object activatedTS) {
        super.handleDefinitionChangedOnActivate(activatedTS);
    }
}
