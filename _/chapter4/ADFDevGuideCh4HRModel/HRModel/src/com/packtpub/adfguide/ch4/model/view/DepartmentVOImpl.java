package com.packtpub.adfguide.ch4.model.view;

import oracle.jbo.Row;
import oracle.jbo.RowMatch;
import oracle.jbo.server.ViewObjectImpl;
import oracle.jbo.server.ViewRowImpl;
import oracle.jbo.server.ViewRowSetImpl;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Sat Oct 15 10:08:20 IST 2011
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class DepartmentVOImpl extends ViewObjectImpl {
    /**
     * This is the default constructor (do not remove).
     */
    public DepartmentVOImpl() {
    }

    public void executeEmptyRowSet() {
        super.executeEmptyRowSet();
    }

    public Object[] executeDetailQuery(Row[] masterRows) {
        return super.executeDetailQuery(masterRows);
    }

    /**
     * Executes the query.
     * <p>
     *
     * This method does not necessarily retrieve data.  The View Object's
     * fetch mode determines whether the rows are retrieved immediately
     * or not.  If <tt>FETCH_AS_NEEDED</tt> is specified, the <code>ResultSet</code>
     * is left open, and the rows are retrieved as the user navigates through
     * the row set.
     * <p>
     *
     * Calling this method will ensure that the user will see the latest
     * data from the database, as well as the data changes that the user has
     * made in the current transaction.
     * <p>
     *
     * If the user changes the SQL statement, or modifies attributes
     * used by it, view rows that were visible may "disappear" after
     * this method is invoked, and the new WHERE clause takes effect.
     * <p>
     *
     * When a row set is first instantiated and the application calls
     * a navigational method such as, <tt>next()</tt>,
     * <tt>previous()</tt>, <tt>first()</tt>, or <tt>last()</tt>,
     * this method is implicitly called.
     * <p>
     *
     * Upon successful execution of the query, this method fires a
     * <code>RangeRefreshEvent</code> event to <code>RowSetListener</code>'s
     * registered with this object, by calling
     * <code>RowSetListener.rangeRefreshed()</code>.
     *
     * @see ViewObjectImpl#setFetchMode
     * @see oracle.jbo.RowSetListener#rangeRefreshed(oracle.jbo.RangeRefreshEvent)
     * @see oracle.jbo.RangeRefreshEvent
     */
    public void executeQuery() {
        super.executeQuery();
    }

    /**
     * This method is invoked right before the row set executes the
     * query.  If this method is overridden, the custom logic
     * will be applied to all row sets.
     *
     * <p>
     * In contrast, if the user overrides the view object's
     * executeQuery(), the custom logic in it only applies only
     * when the user calls executeQuery() on the view object.
     * If he calls executeQuery() on secondary row sets, the
     * custom logic in executeQuery() will not apply.
     *
     * @param qc  the query collection about to execute the query.
     * @param params  the bind parameters that will be applied to the query.
     * @param noUserParams  the number of user bind parameters supplied
     *                      through the setWhereClauseParam calls.
     */
    protected void executeQueryForCollection(Object qc, Object[] params, int noUserParams) {
        super.executeQueryForCollection(qc, params, noUserParams);
    }

    public void forceExecuteQueryOfSharedVO() {
        super.forceExecuteQueryOfSharedVO();
    }

    /**
     * Indicates whether the row set has been executed or not.
     *
     * @return  true if the row set has been executed.
     */
    public boolean isExecuted() {
        return super.isExecuted();
    }

    /**
     * This method delegates to the default <code>RowSet</code>.
     *
     * @see oracle.jbo.RowSet#resetExecuted()
     */
    public void resetExecuted() {
        super.resetExecuted();
    }

    public void prepareRowSetForQuery(ViewRowSetImpl vrs) {
        super.prepareRowSetForQuery(vrs);
    }

    /**
     *  Prepare view object for build query.
     *  In non SI mode, do nothing.
     *  In SI mode,
     *  <ul>
     *    <li> activate the attributes in mNewSelectAttrNameset</li>
     *    <li> activate the attributes that are the source field of links to
     *         child view objects</li>
     *    <li> activate entity objects that are used in the WHERE or ORDER BY
     *         or GROUP BY but not the select</li>
     *    <li> activate join constraint view criteria if necessary</li>
     *  </ul>
     */
    public void prepareVOForQuery() {
        super.prepareVOForQuery();
    }

    /**
     * Evaluates whether the view row qualifies the view object's row match
     * and in-memory filter view criteria.
     * <p>
     *
     * This method is invoked on new view rows as well as view rows coming
     * from query to see if the view row should be added to the query collection.
     *
     * @param   vr   the view row to examine.
     * @return  a <code>boolean</code> value indicating whether the row qualifies
     *          or not.
     */
    protected boolean rowQualifies(ViewRowImpl vr) {
        return super.rowQualifies(vr);
    }

    /**
     * Gets the in-memory filter (<code>RowMatch</code>) for the view object.
     * While the where-clause is used when a database query is issued,
     * the row match is used for qualifying rows in memory.
     *
     * @return the current row match.
     */
    public RowMatch getRowMatch() {
        return super.getRowMatch();
    }

    /**
     * Sets an in-memory filter (<code>RowMatch</code>) for the view object.
     * While the where-clause is used when a database query is issued,
     * the row match is used for qualifying rows in memory.
     * Calling this method does not cause filtering of rows by the
     * row match.  To filter, {@link RowSet#executeQuery()}
     * must be called.
     *
     * @param rowMatch the new row match.
     */
    public void setRowMatch(RowMatch rowMatch) {
        super.setRowMatch(rowMatch);
    }

    protected void setRowMatchFromViewCriteria(RowMatch rowMatch) {
        super.setRowMatchFromViewCriteria(rowMatch);
    }

    /**
     * Returns the bind variable value for bindVarDeptId.
     * @return bind variable value for bindVarDeptId
     */
    public Integer getbindVarDeptId() {
        return (Integer)getNamedWhereClauseParam("bindVarDeptId");
    }

    /**
     * Sets <code>value</code> for bind variable bindVarDeptId.
     * @param value value to bind as bindVarDeptId
     */
    public void setbindVarDeptId(Integer value) {
        setNamedWhereClauseParam("bindVarDeptId", value);
    }

    /**
     * Returns the variable value for bindVarVCDeptId.
     * @return variable value for bindVarVCDeptId
     */
    public Integer getbindVarVCDeptId() {
        return (Integer)ensureVariableManager().getVariableValue("bindVarVCDeptId");
    }

    /**
     * Sets <code>value</code> for variable bindVarVCDeptId.
     * @param value value to bind as bindVarVCDeptId
     */
    public void setbindVarVCDeptId(Integer value) {
        ensureVariableManager().setVariableValue("bindVarVCDeptId", value);
    }
}
