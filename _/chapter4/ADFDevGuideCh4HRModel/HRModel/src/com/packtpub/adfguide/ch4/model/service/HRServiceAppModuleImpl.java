package com.packtpub.adfguide.ch4.model.service;

import com.packtpub.adfguide.ch4.model.service.common.HRServiceAppModule;
import com.packtpub.adfguide.ch4.model.view.DepartmentVOImpl;

import com.packtpub.adfguide.ch4.model.view.MarketingEmployeeListVOImpl;

import oracle.jbo.ApplicationModule;
import oracle.jbo.NameValuePairs;
import oracle.jbo.Row;
import oracle.jbo.RowSet;
import oracle.jbo.Session;
import oracle.jbo.ViewCriteria;
import oracle.jbo.ViewCriteriaRow;
import oracle.jbo.ViewObject;
import oracle.jbo.server.ApplicationModuleImpl;
import oracle.jbo.server.ViewLinkImpl;
import oracle.jbo.server.ViewObjectImpl;
import oracle.jbo.domain.Date;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Wed Oct 26 06:43:46 IST 2011
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class HRServiceAppModuleImpl extends ApplicationModuleImpl implements HRServiceAppModule {
    /**
     * This is the default constructor (do not remove).
     */
    public HRServiceAppModuleImpl() {
    }

    /**
     * Container's getter for Departments.
     * @return Departments
     */
    public DepartmentVOImpl getDepartments() {
        return (DepartmentVOImpl)findViewObject("Departments");
    }

    /**
     * Container's getter for EmployeesForDepartment.
     * @return EmployeesForDepartment
     */
    public ViewObjectImpl getEmployeesForDepartment() {
        return (ViewObjectImpl)findViewObject("EmployeesForDepartment");
    }

    /**
     * Container's getter for Employees.
     * @return Employees
     */
    public ViewObjectImpl getEmployees() {
        return (ViewObjectImpl)findViewObject("Employees");
    }

    /**
     * Container's getter for MarketingEmployeeList.
     * @return MarketingEmployeeList
     */
    public ViewObjectImpl getMarketingEmployeeList() {
        return (ViewObjectImpl)findViewObject("MarketingEmployeeList");
    }

    /**
     * Container's getter for EmployeeDeptDetails.
     * @return EmployeeDeptDetails
     */
    public ViewObjectImpl getEmployeeDeptDetails() {
        return (ViewObjectImpl)findViewObject("EmployeeDeptDetails");
    }

    /**
     * Container's getter for EmpDeptFkLink1.
     * @return EmpDeptFkLink1
     */
    public ViewLinkImpl getEmpDeptFkLink1() {
        return (ViewLinkImpl)findViewLink("EmpDeptFkLink1");
    }

    /**
     * Container's getter for CountryVO1.
     * @return CountryVO1
     */
    public ViewObjectImpl getCountries() {
        return (ViewObjectImpl)findViewObject("Countries");
    }

    /**
     * Container's getter for LocationVO1.
     * @return LocationVO1
     */
    public ViewObjectImpl getLocations() {
        return (ViewObjectImpl)findViewObject("Locations");
    }

    /**
     * Container's getter for CountryLocFkLink1.
     * @return CountryLocFkLink1
     */
    public ViewLinkImpl getCountryLocFkLink1() {
        return (ViewLinkImpl)findViewLink("CountryLocFkLink1");
    }

    /**
     * Container's getter for LocationVO1.
     * @return LocationVO1
     */
    public ViewObjectImpl getLocationDetails() {
        return (ViewObjectImpl)findViewObject("LocationDetails");
    }

    public void test() {
        ViewObjectImpl vo = getDepartments();
        vo.executeQuery();
        //Fetch rows from the ResultSet
        //  while (vo.hasNext()) {
        //      Row row = vo.next();
        //Work with empRow
        //     System.out.println(row);
        //  }

    }

    /**
     * Container's getter for JobHistoryVO1.
     * @return JobHistoryVO1
     */
    public ViewObjectImpl getJobHistoryDetails() {
        return (ViewObjectImpl)findViewObject("JobHistoryDetails");
    }

    /**
     * Prepare the ApplicationModule and/or the JDBC session.
     * Application developers may extend this method to initialize JDBC or
     * ApplicationModule session state.  For example, a developer could extend
     * this method to prepare PL/SQL session state which is related to a
     * virtual private database.  A developer may also extend this method to
     * initialize state in the ApplicationModule Session.
     * <p>
     * The application module may be assumed to be in a valid, connected
     * state when this method is invoked.
     * <p>
     * This method is invoked when:
     * <p>
     * 1.  An ApplicationModule is first created.
     * <p>
     * 2.  An ApplicationModule is associated with a user
     * session -- typically an ApplicationModuleHandle that was created by the
     * pooling framework.  Note that a handle may be
     * disassociated from an ApplicationModule as ApplicationModules are
     * recycled.  prepareSession will be invoked when the handle is
     * associated with a new ApplicationModule, before the handle's state
     * is activated.
     * <p>
     * 3.  An ApplicationModule session is reconnected to a database.
     * <p>
     * @see #getSession()
     */
    protected void prepareSession(Session session) {
        super.prepareSession(session);
       // setProperty(ApplicationModule.EFF_DT_PROPERTY_STR, new Date("2008-10-01"));
       
    }

    /**
     * Finds the named View Object.  The View Object name passed
     * in (<code>voName</code>) may or may not be qualified with the name
     * of the containing Application Module.  If it is, the View Object
     * name is said to be <em>an AM-qualified View Object name</em>.  If not, the name
     * is said to be <em>an unqualified View Object name</em>.
     * <p>
     *
     * An AM-qualified name is a multi-part name (separated by dots).
     * The last part of the name is the View Object name (<em>View Object
     * part of the name</em>).  All preceding parts consistitute the name of
     * the Application Module that contains the View Object.  For an AM-qualified
     * name, <tt>findViewObject()</tt> first locates the containing Application
     * Module using the Application Module name.  In fact, it uses
     * {@link #findApplicationModule(String)} to find the Application
     * Module.  Thus, the Application Module name in an AM-qualified View Object
     * name may be relative or absolute Application Module name.
     * See <tt>findApplicationModule()</tt> discussions on absolute
     * and relative Application Module names.  Once
     * the Application Module is found, the View Object part is used to
     * find the View Object in that Application Module.
     * <p>
     *
     * If the View Object name is unqualified, the search for the View
     * Object is made on this Application Module.
     * <p>
     *
     * For example, suppose we have the following containership of nested
     * Application Modules and View Objects:
     * <p>
     * <pre>
     *    Root (root Application Module)
     *       ChildAM1
     *          ViewObjectA
     *          GrandChildAM1_1
     *             ViewObjectB
     *          GrandChildAM1_2
     *             GreatGrandChildAM1_2_1
     *                ViewObjectC
     *       ChildAM2
     *          GrandChildAM2_1
     *             ViewObjectD
     * </pre>
     * <p>
     *
     * <tt>ChildAM1.findViewObject("GrandChildAM1_2.GreatGrandChildAM1_2_1.ViewObjectC")</tt>
     * will succeed (using relative Application Module name).
     * <p>
     *
     * <tt>ChildAM2.findViewObject("Root.ChildAM1.GrandChildAM1_2.GreatGrandChildAM1_2_1.ViewObjectC")</tt>
     * will succeed (using absolute Application Module name) and return the
     * same View Object as <tt>ChildAM1.findViewObject("GrandChildAM1_2.GreatGrandChildAM1_2_1.ViewObjectC")</tt>.
     * <p>
     *
     * Both these are AM-qualified name cases.
     * <p>
     * <tt>GrandChildAM2_1.findViewObject("ViewObjectD")</tt> will succeed.  This is
     * is an unqualified name case.
     * <p>
     *
     * For View Object searching, <tt>findViewObject()</tt> makes
     * no distinction between View Objects included the
     * Application Module during design time and those created programmatically
     * during runtime.
     *
     * <p>
     * Example code:
     * <p>
     * <pre>
     *    ViewObject vo = am.findViewObject("MyVO");
     * </pre>
     * <p>
     *
     * @param voName the name of the View Object.
     * @return the View Object.  <code>null</code> if the View Object
     *         is not found.
     * @throws NoObjException if an AM-qualified name was specified and the
     *                       containing Application Module could not be found.
     * @throws InvalidObjNameException if <code>voName</code> is an invalid name.
     *                                <code>voName</code> must be a vaild Java name.
     *
     * @see #findApplicationModule(String)
     * @see #findViewLink(String)
     */
    public ViewObject findViewObject(String voName) {

        setProperty(ApplicationModule.EFF_DT_PROPERTY_STR, new Date("2005-10-05"));
        return super.findViewObject(voName);
    }

    public void searchInMemoryWithoutAffetingDefaultRowset() {
        ViewObject vo = findViewObject("Countries");
        vo.executeQuery();
        // showRows(vo, "Print All rows");
        //Define VC for in-memroy filtering
        ViewCriteria countryStartsWithA = vo.createViewCriteria();
        countryStartsWithA.setCriteriaMode(ViewCriteria.CRITERIA_MODE_CACHE);
        ViewCriteriaRow vcr1 = countryStartsWithA.createViewCriteriaRow();
        vcr1.setAttribute("CountryName", "LIKE A%");
        countryStartsWithA.add(vcr1);
        //Set In memory VC mode
        countryStartsWithA.setCriteriaMode(ViewCriteria.CRITERIA_MODE_CACHE);
        //Perfrom in-memory filter and get new row set
        RowSet rs = (RowSet)vo.findByViewCriteria(countryStartsWithA, -1, ViewObject.QUERY_MODE_SCAN_VIEW_ROWS);

    }
}
